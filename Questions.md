1. 

2. 模板化（template）和Java中泛型类似，怎么实现的？

3. 静态变量一定要在类定义之外分配空间？

4. 为什么一个对象要像指针，或者像函数？

5. 构造函数，变量初始化很特别，用冒号，比如

   ```c++
   //complex类，rm和im为数据
   complex(double r=0,double i=0) : rm(r),im(i){
   	
   }
   ```

   

6. 函数重载overloading，需要参数不同，因为编译器编译的时候函数名称不只有函数名，还有参数的相关信息，所以对编译器来说是不一样的。**但是如果某函数的每个参数都有默认值，则重载的函数不能0变量，不然就分辨不出来**

7. 构造函数放在private，表示不允许外界创造该类的实例（比如singleton中，类里面创建了该类的实例，外界可以调用该实例，但是不能再新建了，所以叫单例模式）

8. **数据一般放在private**

9. 注意const，表示**该函数不会修改变量的值**，如果不加，当类的实例为const时，就会出错，不能调用该函数

10. **传参和返回值一般用引用（reference）效率高，因为只传地址，不想修改就加const修饰**

11. c++中的**引用变量**，**相当于是其他某个变量的别名**，修改它，指向的那个变量也会变，一般编译器就会认为**引用变量相当于一个const指针**，因为必须初始化，而且初始化后不会改变。[简谈 C++ 中指针与引用的底层实现 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/89175296), 使用时又相当于一个解引用指针，修改或者访问的都是指向的东西。

12. 用reference时，传递者无需知道接受者是以什么形式接受的（不管是传参还是返回值），如果以reference接受，就只传地址，如果以value接收，就传value，都能传成功。

13. 当返回的这个变量，之前并没有分配空间，**是在函数内部分配的时候，不能return by reference**, 一定要return by value，因为如果是reference，函数结束的时候指向的那个变量就死亡了，就没了。

14. inline的作用：在使用该函数的时候，编译器会直接将它变为函数体，这样就减少了函数调用的开销。**但是inline只是给编译器的一个建议，编译器会自己判断**

15. 对于一个类的多个对象，非静态的变量每个对象都有一份，**非静态的函数却也只有一份**，大家共用，**通过隐含的this来区分**，而静态的成员则都只有一份。

16. 什么时候使用静态变量：该变量不会随着对象不同而改变。

17. 静态函数：**静态函数没有this指针**，所以不能使用非静态的变量

18. const是函数签名的一部分，所以两个同名函数可以用是否有const来区分。

19. 继承：对变量来说是内存上包含了父类的变量，对函数来说是继承了父类的函数的**调用权**，与内存无关。

20. 注意pop()并不会返回top值。

21. 注意动态绑定的三个条件。

22. 函数指针是什么

23. allocator原理，本质

