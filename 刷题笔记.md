# 刷题笔记

## 易忘点

### 创建对象的几种方式

```c++
//显式创建
//会创建一个临时对象，然后将临时对象复制到person中，并丢弃临时对象。此时，将为临时对象调用析构函数
Person person = Person("ker",23);
//隐式调用
//与上面一样，只是换一种格式
Person person("ker",23);
//使用默认构造函数显式调用
Person person = Person();
//使用默认构造函数隐式调用
Person person;

//上面的方式都是得到的对象，创建时会生成临时对象，空间分配在栈中
//使用new关键字是会调用malloc在堆中分配空间，需要我们自己释放
Person* person = new Person("ker",123);
//用了new一定记得delete
delete person;
```

### vector的操作

1. size()
2. front(), back()
3. push_back(), emplace_back()
4. erase(), 

### priority_queue的操作

1. 构造

   ```c++
   priority_queue<typename,container<typename>,compare<typename> queue(it.begin(),it.end())
   priority_queue<Type, Container, Functional>
   //例如
   priority_queue<MyStruct,vector<MyStruct>,less<MyStruct>> queue(it.begin(),it.end())
   
   //对于compare，可以用自己的比较方式，有两种方法
   //对于自己构建的类，比如MyStruct，可以在MyStruct中overload操作符<，相当于less<MyStruct>中less会调用MyStruct操作符<来进行比较
   bool operator< (MyStruct& s) const{
   	
   }
   priority_queue<MyStruct> queue;
   //也可以自己构建一个compare类（function-like class），这个类需要覆写operator（）来实现比较
   class cmp{
       bool operator()(MyStruct s1,MyStruct s2){
           return s1.time<s2.time;
       }
   }
   priority_queue<MyStruct,vector<MyStruct>,cmp> queue;
   ```

2. 基本操作

   ```
   queue.emplace(...);
   queue.top();
   queue.pop();
   queue.push();
   queue.size();
   ```

   

### 杂项

1. pop()并不会返回top值。

### 一些常用函数

1. std::stoi(string str)：字符串转int
2. std::reverse(iterator begin,iterator end)：反转，可以用来反转字符串



## 循环用快慢指针

1. 看到判断是否有循环，就可以考虑快慢指针

2. 判断循环的入口，考虑用数学思维。（142. 环形链表）

   面试题 02.07. 链表相交 也考虑用数学规律

## 几数之和

1. 如果要求是几个数的下标，则不能排序，这需要用map或set记录。（1. 两数之和）
2. 如果只是需要数的值，，则可以用排序，这时候考虑双指针。其他指针固定，两个指针动。（ 第15题. 三数之和，第18题. 四数之和）

## 单调队列

1. 239.滑动窗口最大值题，维护一个单调队列，队头的值一直为最大值，并单调递减，队列中不存在位置在队头前的数，

## 二叉树

### 遍历

1. 迭代式遍历，一个节点一开始放进去并不会读取，只是用来加入其它的节点，并在该节点上方加一个标记(nullptr)，第二次读到的时候从栈中弹出。如下是中序遍历，其它遍历只需要变更顺序就好了

```c++
class Solution {
public:
    vector<int> res;
    vector<int> inorderTraversal(TreeNode* root) {
        if (root == nullptr){
            return res;
        }
        stack<TreeNode*> stack;
        stack.push(root);
        while (!stack.empty()){
            TreeNode* cur = stack.top();
            stack.pop();
            if (cur == nullptr){
                TreeNode* n = stack.top();
                stack.pop();
                res.push_back(n->val);
            }else{
                if (cur->right != nullptr){
                    stack.push(cur->right);
                }
                stack.push(cur);
                stack.push(nullptr);
                if (cur->left != nullptr){
                    stack.push(cur->left);
                }
            }
        }
        return res;
    } 
};
```

2. 层序遍历模板，用一个队列

```
vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (root==nullptr){
            return res;
        }
        queue<TreeNode*> queue;
        queue.push(root);
        vector<int> temp;
        while (!queue.empty()){
            temp = vector<int>();
            //相当于遍历当前层
            int size = queue.size();
            for (int i=0;i<size;++i){
                TreeNode* cur = queue.front();
                queue.pop();
                //在这里进行操作，根据题目意思来
                temp.push_back(cur->val);
                //把下一层节点添加进去
                if (cur->left!=nullptr){
                    queue.push(cur->left);
                }
                if (cur->right!=nullptr){
                    queue.push(cur->right);
                }
            }
            res.push_back(temp);
        }
        return res;
    }
```

