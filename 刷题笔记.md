# 刷题笔记

## 易忘点

### 创建对象的几种方式

```c++
//显式创建
//会创建一个临时对象，然后将临时对象复制到person中，并丢弃临时对象。此时，将为临时对象调用析构函数
Person person = Person("ker",23);
//隐式调用
//与上面一样，只是换一种格式
Person person("ker",23);
//使用默认构造函数显式调用
Person person = Person();
//使用默认构造函数隐式调用
Person person;

//上面的方式都是得到的对象，创建时会生成临时对象，空间分配在栈中
//使用new关键字是会调用malloc在堆中分配空间，需要我们自己释放
Person* person = new Person("ker",123);
//用了new一定记得delete
delete person;
```

### vector的操作

1. size()
2. front(), back()
3. push_back(), emplace_back()
4. erase(), 

### priority_queue的操作

1. 构造

   ```c++
   priority_queue<typename,container<typename>,compare<typename> queue(it.begin(),it.end())
   priority_queue<Type, Container, Functional>
   //例如
   priority_queue<MyStruct,vector<MyStruct>,less<MyStruct>> queue(it.begin(),it.end())
   
   //对于compare，可以用自己的比较方式，有两种方法
   //对于自己构建的类，比如MyStruct，可以在MyStruct中overload操作符<，相当于less<MyStruct>中less会调用MyStruct操作符<来进行比较
   bool operator< (MyStruct& s) const{
   	
   }
   priority_queue<MyStruct> queue;
   //也可以自己构建一个compare类（function-like class），这个类需要覆写operator（）来实现比较
   class cmp{
       bool operator()(MyStruct s1,MyStruct s2){
           return s1.time<s2.time;
       }
   }
   priority_queue<MyStruct,vector<MyStruct>,cmp> queue;
   ```

2. 基本操作

   ```
   queue.emplace(...);
   queue.top();
   queue.pop();
   queue.push();
   queue.size();
   ```

   

### 杂项

1. pop()并不会返回top值。

### 一些常用函数

1. std::stoi(string str)：字符串转int
2. std::reverse(iterator begin,iterator end)：反转，可以用来反转字符串



## 循环用快慢指针

1. 看到判断是否有循环，就可以考虑快慢指针

2. 判断循环的入口，考虑用数学思维。（142. 环形链表）

   面试题 02.07. 链表相交 也考虑用数学规律

## 几数之和

1. 如果要求是几个数的下标，则不能排序，这需要用map或set记录。（1. 两数之和）
2. 如果只是需要数的值，，则可以用排序，这时候考虑双指针。其他指针固定，两个指针动。（ 第15题. 三数之和，第18题. 四数之和）

## 单调队列

1. 239.滑动窗口最大值题，维护一个单调队列，队头的值一直为最大值，并单调递减，队列中不存在位置在队头前的数，